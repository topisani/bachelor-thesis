\newcommand{\Ident}{\ensuremath{\textrm{ident}}}
\newcommand{\Cut}{\ensuremath{\textrm{cut}}}
\newcommand{\Sequential}{\ensuremath{\textrm{seq}}}
\newcommand{\Parallel}{\ensuremath{\textrm{par}}}
\newcommand{\Recursive}{\ensuremath{\textrm{rec}}}
\newcommand{\Resample}{\ensuremath{\textrm{resample}}}
\newcommand{\Split}{\ensuremath{\textrm{split}}}
\newcommand{\Merge}{\ensuremath{\textrm{merge}}}
\newcommand{\Ins}{\ensuremath{\textbf{ins}}}
\newcommand{\Outs}{\ensuremath{\textbf{outs}}}
\newcommand{\Sig}{\ensuremath{\mathbb{S}}}
\newcommand{\SigP}[1]{\ensuremath{\llbracket #1 \rrbracket}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Block Diagrams}
\label{chap:blocks}

\section{Algebra of Blocks}

In the 2002 paper \emph{An Algebraic approach to Block Diagram Constructions}\autocite{orlarey2002} Orlarey et al introduce a series of five
basic block diagram operations, which are expanded in \autocite{orlarey2004} with two extra compositional
operations, split and merge. The rest of this chapter introduces this algebra of blocks in a language very
similar to \autocite{orlarey2004}, with minor differences in syntax and semantics noted along the way.

\begin{description}
  \item[A Signal] is a discrete function of time, such that the value of a signal $s \in \Sig$ at time
        $t$ is denoted $s(t)$. The full set of all signals is written as
        $\Sig = \mathbb N \rightarrow \mathbb R$. Signals are mostly used in signal tuples, denoted as $(s_1, \dots, s_n) \in \Sig^n$. To
        simplify the semantic specifications in the following section, tuples of signal tuples are always flattened,
        i.e. $\forall s \in \Sig: s = (s)$, and $\forall a \in \Sig^n, b \in \Sig^m : (a, b) = (a_1, \dots, a_n, b_1, \dots, b_m)$

        In use with AD/DA converters and other audio software, it is convention to let the full range of signals be
        $[-1; 1]$, and mostly this is represented as a 32-bit floating point value. Notice however, that
        signals may exceed this range, although inputs and outputs of the top-level signal processor should not.

  \item[A Signal Processor] is a function $S^n \rightarrow S^m$, and the object of the model. Signal processors are
        a transformation from a number of \emph{input} signals to a number of \emph{output}
        signals, which are evaluated for each time value $t$ in order. The result
        $p(s)(t)$ of signal processor $p$ may depend on $s(t')$ for
        all $t' < t$, in other words, signal processors may have \emph{memory}.

        The full set of signal processors is notated as $\mathbb P = \bigcup_{n,m} \Sig^n \rightarrow \Sig^m$

  \item[A Block] is the computational unit used to model signal processors. It is described in terms of the
        recursive language $\mathbb D$:
        \begin{align*}
          d, d_1, d_2 \in \mathbb{D} & ::= b \in \mathbb{B}      \\
                                     & |\; \Ident                \\
                                     & |\; \Cut                  \\
                                     & |\; \Sequential(d_1, d_2) \\
                                     & |\; \Parallel(d_1, d_2)   \\
                                     & |\; \Recursive(d_1, d_2)  \\
                                     & |\; \Split(d_1, d_2)      \\
                                     & |\; \Merge(d_1, d_2)      \\
        \end{align*}
        Here, $\mathbb B$ denotes a domain-specific set of primitive blocks. Some of these will be
        addressed in a later section.

        Faust and the related papers\autocite{orlarey2002,orlarey2004} uses single-character operator syntax for the basic
        operators of $\mathbb D$, but since the same syntax cannot be achieved exactly in C++, I will be
        referring to them by their names as prefix functions to avoid confusion. The later chapter on the C++
        implementation will cover the chosen syntax.

        To separate the syntax of blocks from the semantics, the function $\SigP{\ .\ } : \mathbb D
          \rightarrow \mathbb P$ is used to map a
        block diagram $d$ to the corresponding signal processor $\SigP{d}$.

        We also introduce the type-like syntax $d : i \rightarrow o$ to mean $\SigP{d} : \Sig^i \rightarrow \Sig^o$. This is useful
        for declaring the type rules, which are covered in the following section.
\end{description}

\subsection{Basic block operations}
Each of these seven block operations is described in detail by the FAUST authors in \autocite{orlarey2002}
and \autocite{orlarey2004}, so here I will only give a brief introduction to each one, along with an example
illustration and the type rules. Some are slightly simplified here when possible to still get the same
expressivity, in those cases it will be noted.

\begin{table}[]
  \centering
  \begin{tabular}{|l|c|c|c|c|}
    \hline
    $d$                     & Faust Syntax   & EDA Syntax     & $\Ins(d)$                & $\Outs(d)$                \\
    \hline\hline
    \Ident                  & \cpp{_}        & \cpp{_}        & 1                        & 1                         \\
    \Cut                    & \cpp{!}        & \cpp{cut}      & 1                        & 0                         \\
    $\Sequential(d_1, d_2)$ & \cpp{d1 : d2}  & \cpp{d1 | d2}  & $\Ins(d_1)$              & $\Outs(d_2)$              \\
    $\Parallel(d_1, d_2)$   & \cpp{d1 , d2}  & \cpp{d1 , d2}  & $\Ins(d_1) + \Ins(d_2)$  & $\Outs(d_1) + \Outs(d_2)$ \\
    $\Recursive(d_1, d_2)$  & \cpp{d1 ~ d2}  & \cpp{d1 \% d2} & $\Ins(d_1) - \Outs(d_2)$ & $\Outs(d_1)$              \\
    $\Split(d_1, d_2)$      & \cpp{d1 <: d2} & \cpp{d1 << d2} & $\Ins(d_1)$              & $\Outs(d_2)$              \\
    $\Merge(d_1, d_2)$      & \cpp{d1 :> d2} & \cpp{d1 >> d2} & $\Ins(d_1)$              & $\Outs(d_2)$              \\
    \hline
  \end{tabular}
  \caption{Basic block diagram compontents and their properties and syntax}
  \label{tab:blocks}
\end{table}

\subsubsection{Identity}
The $\Ident$ block is the simplest block - it simply takes one input signal, and outputs that
same signal untouched.

\begin{minipage}{0.5\linewidth}
  \begin{align*}
    \Ident: 1        & \rightarrow 1 \\
    \SigP{\Ident}(s) & = s
  \end{align*}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{figure}[H]
    \centering
    \label{fig:block_ident}
    \includestandalone[]{Pictures/block_ident}
  \end{figure}
\end{minipage}

\subsubsection{Cut}
The $\Cut$ block takes one input signal and outputs nothing. It can be very useful for
discarding signals when composing blocks.

\begin{minipage}{0.5\linewidth}
  \begin{align*}
    \Cut: 1        & \rightarrow 0 \\
    \SigP{\Cut}(s) & = ()
  \end{align*}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{figure}[H]
    \centering
    \label{fig:block_cut}
    \includestandalone[]{Pictures/block_cut}
  \end{figure}
\end{minipage}

\subsubsection{Sequential block composition}
The simplest composition of two blocks is passing the outputs of one block to the inputs of another in
sequence. It requires the number of outputs of the first block to equal the number of inputs on the second.
Faust has defined semantics for when this is not the case as well, but since those cases can all be covered
by combinations of sequential and parallel compositions, they have been left out here for simplicity.

\begin{minipage}{0.5\linewidth}
  \begin{prooftree}
    \AxiomC{$d_1 : n \rightarrow p$}
    \AxiomC{$d_2 : p \rightarrow m$}
    \BinaryInfC{$\Sequential(d_1, d_2) : n \rightarrow m$}
  \end{prooftree}
  \begin{align*}
    \SigP{\Sequential(d_1, d_2)}(s_1, \dots, s_n)    ={} & \SigP{d_2}\left(\SigP{d_1}(s_1, \dots, s_n)\right)
  \end{align*}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{figure}[H]
    \centering
    \label{fig:block_seq}
    \includestandalone[]{Pictures/block_seq}
  \end{figure}
\end{minipage}

\subsubsection{Parallel block composition}
The parallel composition of two blocks can be intuitively seen as a concatenation of their input and output
signals, resulting in a block where the two components are evaluated separately on their own segments of the
input.

\begin{minipage}{0.5\linewidth}
  \begin{prooftree}
    \AxiomC{$d_1 : i_1 \rightarrow o_1$}
    \AxiomC{$d_2 : i_2 \rightarrow o_2$}
    \BinaryInfC{$\Parallel(d_1, d_2) : i_1 + i_2 \rightarrow o_1 + o_2$}
  \end{prooftree}
  \begin{align*}
    \SigP{\Parallel(d_1, d_2)}(s_1, \dots, s_{i_1}, x_1, \dots, x_{i_2}) ={} ( & \SigP{d_1}(s_1, \dots, s_{i_1}),   \\
                                                                               & \SigP{d_2}(x_{1}, \dots, x_{i_2})) \\
  \end{align*}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{figure}[H]
    \centering
    \label{fig:block_par}
    \includestandalone[]{Pictures/block_par}
  \end{figure}
\end{minipage}

\subsubsection{Recursive block composition}
The recursive block composition is the most complex. Its purpose is to create cycles in the block diagram, by
allowing a block to access the output it generated in the previous iteration. The outputs of
$d_1$ are connected to the corresponding inputs of $d_2$, and the outputs
of $d_2$ are connected to the corresponding inputs of $d_1$. The inputs to
the composition are the remaining inputs to $d_1$, and the outputs are all outputs of
$d_1$.

Since the recursion requires a cycle, the output from $d_1$ that is passed to
$d_2$ is delayed by one sample, i.e. by one iteration. On the illustrations, this is denoted
by a small square on the connection.

\begin{minipage}{0.5\linewidth}
  \begin{prooftree}
    \AxiomC{$d_1 : i_1 \rightarrow o_1$}
    \AxiomC{$d_2 : i_2 \rightarrow o_2$}
    \AxiomC{$o_2 \leq i_1$}
    \AxiomC{$i_2 \leq o_1$}
    \QuaternaryInfC{$\Recursive(d_1, d_2) : i_1 - o_2 \rightarrow o_1$}
  \end{prooftree}
  \begin{prooftree}
    \AxiomC{$
        \SigP{d_2}(y'_1,\dots, y'_{i_2}) = (r_1, \dots, r_{o_2}) \\
        \SigP{d_1}(r_1, \dots, r_{o_2}, s_1, \dots, s_{n}) = (y_1,\dots, y_{o_2})
      $ }
    \UnaryInfC{$\SigP{\Recursive(d_1, d_2)}(s_1, \dots, s_{n}) ={} & (y_1, \dots, y_{o_2})$}
  \end{prooftree}
  Where $y'$ is the signal $y$ delayed by one sample, i.e \\
  $\forall y \in \Sig, t \in \mathbb{N}^+ : y'(0) = 0, y'(t) = y(t - 1)$
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{figure}[H]
    \centering
    \label{fig:block_rec}
    \includestandalone[]{Pictures/block_rec}
  \end{figure}
\end{minipage}

\subsubsection{Split block composition}
The split composition is used to sequentially compose blocks where the first one has fewer outputs than the
second has inputs. The output signals are connected by repeating the entire output tuple the apropriate
number of times, and this number is required to be an integer. This means $\Ins(d_2)$ must be an
exact multiple of $\Outs(d_1)$. \newcommand{\Mod}{\mathrm{\ mod\ }}
\begin{minipage}{0.5\linewidth}
  \begin{prooftree}
    \AxiomC{$d_1 : i_1 \rightarrow o_1$}
    \AxiomC{$d_2 : o_1 * k \rightarrow o_2$}
    \AxiomC{$k \in \mathbb{N}$}
    \TrinaryInfC{$\Split(d_1, d_2) : i_1 \rightarrow o_2$}
  \end{prooftree}
  \begin{align*}
    \Split(d_1, d_2)(\mathbf{x})                ={} &
    \begin{aligned}[t]
      d_2( & d_1(\mathbf{x})_{1 \Mod m_1}, \dots, \\
           & d_1(\mathbf{x})_{n_2\Mod m_1})
    \end{aligned}
  \end{align*}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{figure}[H]
    \centering
    \label{fig:block_split}
    \includestandalone[]{Pictures/block_split}
  \end{figure}
\end{minipage}

Note that $\Split(d_1, d_2)$ is equal to $\Sequential(d_1, d_2)$ when $k = 1$

\subsubsection{Merge block composition}

Merge composition is the inverse operation of split composition, i.e. it is used to sequentially compose two
blocks where the first one has more outputs than the second one. It places similar restrictions on
$d_1$ and $d_2$ as split composition, i.e. it requires
$\Outs(d_1) = \Ins(d_2) * k$, where $k$ is an integer.

When multiple outputs from $d_1$ are connected to a single input on $d_2$,
the signals are summed. Like split composition, $\Merge(d_1, d_2)$ is also equivalent
$\Sequential(d_1, d_2)$ when $k = 1$.

\begin{minipage}{0.5\linewidth}
  \begin{prooftree}
    \AxiomC{$d_1 : \Sig^{n} \rightarrow \Sig^{p*k}$}
    \AxiomC{$d_2 : \Sig^{p} \rightarrow \Sig^m$}
    \AxiomC{$k \in \mathbb{N}$}
    \TrinaryInfC{$\Split(d_1, d_2) : \Sig^n \rightarrow \Sig^m$}
  \end{prooftree}
  \begin{align*}
    \Merge(d_1, d_2)(\mathbf{x})                ={} &
    \begin{aligned}[t]
      d_2\Biggl( & \left(\sum^{{m_1}/{n_2} - 1}_{i=0}d_1(\mathbf{x})_{i \cdot n_2 + 1}\right), \dots,    \\
                 & \left(\sum^{{m_1}/{n_2} - 1}_{i=0}d_1(\mathbf{x})_{i \cdot n_2 + n_2}\right)  \Biggr)
    \end{aligned}
  \end{align*}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{figure}[H]
    \centering
    \label{fig:block_merge}
    \includestandalone[]{Pictures/block_merge}
  \end{figure}
\end{minipage}

\subsection{Domain Specific Blocks}

\subsubsection{Arithmetic}
\subsubsection{Memory}
\subsubsection{Delay}
\subsubsection{Ref}
\subsubsection{Ref}

\section{C++ Implementation}

When implementing this algebra of blocks in C++, I used the basic concepts of expression templates to
separate building an AST from evaluating it. This has the advantage that multiple visitors can be implemented
for the AST, such as a basic evaluator, an optimizer, a buffer-based evaluator or even one that outputs a
visual representation of the AST, like fausts block diagram generator.

The AST is represented by nodes that satisfy the concept \concept{ABlock}, which just requires a block
\cpp{T} to inherit from \cpp{BlockBase<T, T::in_channels, T::out_channels>}. \cpp{BlockBase} is a CRTP
\footnote{Curriously Recurring Template Pattern, see \url{https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern}} base class, and provides \cpp{T::in_channels}, \cpp{T::out_channels}, and the
function call operator overload required for currying.

\subsection{\cpp{BlockBase} and \cpp{ABlock}}
\subsection{Literals}
\subsection{Currying}
\subsection{Repeat}
\subsection{Operator overloads and shorthand syntax}

\subsection{\cpp{evaluator}}
For simplicity, I assume \cpp{float} for all signals. \subsection{\cpp{Frame}}
