\chapter{Review of Existing Material} \label{sec:review}

\todo{more examples}

This chapter will cover some examples of existing solutions for writing DSP for audio applications in C++,
along with examples of C++ libraries from other domains that attempt to solve similar issues.

\section{Faust}
Faust is described as a \emph{"functional programming language for sound synthesis and audio processing with a strong focus on the design
  of synthesizers, musical instruments, audio effects, etc."\autocite{faustwebsite}} Here, especially the notion of \emph{functional} is
interesting. Faust is written as a purely function processing pipeline, which allows for lazy evaluation and
common subexpression elimination\footnote{CSE: If the same subexpression appears in several places, the code is rearranged to only compute the value once}. An example of basic faust code can be seen in
\autoref{faustex1}. This functional style also abstracts away nearly all implementation details with
regards to buffers, code vectorization, loops etc, and represents purely the intent of the programmer in
terms of the high level DSP algorithms. Thus, faust is a DSL for \emph{specification} of DSP algorithms,
which can then be compiled/transpiled to various targets, including C++, JAVA, WebAssembly etc. Other than
just targeting multiple languages, Faust includes a system called \emph{architectures}, which defines
wrapper classes and files, allowing embedding in any system, such as smartphone applications, plugins for
audio software, web apps etc.

\begin{listing}
  \label{faustex1}
  \caption{ Example faust code. Pass a mono signal in, add white noise scaled to 0.5, split the signal into two channels, and pass one channel through a low pass filter, and one through a high pass filter }
  \begin{cppcodenl}
  filter = low_pass(5000, 0.2)
  process = _ + std.noise * 0.5 <: filter, high_pass(100, 0.1)
  \end{cppcodenl}
\end{listing}

Even though Faust might seem like the perfect solution at first sight, it has two major shortcomings.

Firstly, even with the \emph{architecture} system, interoperability is between faust and the surrounding
host code is still hard, especially when embedding in a larger system. Faust is fairly simple in terms of
interop, and the architectures are defined in terms of functions describing user interfaces, which are
awkward to use when the DSP is separated from the UI. For example, to add a volume input parameter to a faust
program, one would use either the \cpp{vslider} or \cpp{hslider} functions, which represent the UI elements
vertical and horizontal slider respectively. These functions also take a default value, minimum value,
maximum value and step size, which are all options better suited for a separate UI implementation, especially
when these options are not controlled directly by UI elements, but instead by some surrounding application
code. These parameters are then (in C++) exposed to the host architecture as a string name for the slider and
a reference to the float, leading to unchecked matching against strings, which is an area prone to errors.

Secondly, faust does not support resampling and multi-rate algorithms. This means that very important DSP
algorithms like Fast Fourier Transform cannot be efficiently implemented. To make matters worse, there is no
practical way to \emph{inject} natively implemented algorithms into faust, or to step out of faust
for an efficient implementation of some sub-algorithm. This is of course a fairly common issue with DSLs,
where even if this is possible, it is often not easy and practical. For something like DSP it is very
important to be able to hand-roll optimizations, especially of the often reused inner algorithms, where there
exist implementations that are optimized many fold beyond what's possible in a high level of abstraction like
faust.

Faust thus displays both the strengths and weaknesses of a high-level functional DSL: Composition of
algorithms and designing signal chains is easy, and the code closely represents the block diagram and the
mental model of the programmer, without being distracted by implementation details. However, this abstraction
comes at the price of efficiency and ability to tweak the individual algorithms for platform-specific
optimizations, along with being out of options when features are missing, like sample rate conversions, which
are not only important for efficiency, but also sometimes for quality.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{KFR}

KFR Introduces itself as being a framework \emph{"packed with ready-to-use C++ classes and functions for various DSP tasks from high-quality filtering to
  small helpers to improve development speed"}\autocite{kfrwebsite}. It is especially
noteworthy for having a portable FFT implementation that often performs better than FFTW,
\emph{the Fastest Fourier Transform in the West}\autocite{FFTW05}, but also offers high-performance implementations of many common
DSP algorithms, like FIR filtering, IIR filtering, fast incremental sine/cosine generation, stereo
conversions, delay lines, biquad filters etc\autocite{kfrwebsite}. All of these algorithms are optimized for
various SIMD instruction sets, including SSE, AVX and NEON.

The algorithms in KFR can be applied to data in their custom \cpp{univector<T, N>} container, which essentially models a \cpp{std::span<T>},
\cpp{std::array<T, N>}, or \cpp{std::vector<T>} depending on the value of the parameter \cpp{N}. Using this class, the algorithms can be applied to data from many different sources, resulting in a system that can be easily integrated with any form of audio API, UI parameters etc. The user implements a \cpp{process}
function, which takes a \cpp{univector<float, N>} or similar, and applies filters and algorithms to it as they please. Having access to the raw array of floats (in the form of a \cpp{univector}) also means it is very easy to do manual processing
or combine it with functions from other libraries, even where only raw C APIs are available.

What is gained over Faust in performance and interoperability however, is lost in compositional expressivity.
While KFR includes basic support for lazy evaluation of expressions involving \cpp{univector}s, it
lacks the ability to describe the process function as a proper pipline of composed operations.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Eigen}

Eigen is \emph{"a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms"}\autocite{eigenweb}. It is often used as the canonical example of
Expression Templates in C++, and is especially interesting since it is one of the oldest most well-tested
cases of this technology. It is currently used by projects like Google's Tensorflow\autocite{tensorflow2015-whitepaper} and
MIRA, a middleware for robotics\autocite{Einhorn2012-bx}.

The Library provides, amongst other things, a simple and efficient interface for matrix operations, which are
implemented using operator overloading and expression templates. This means syntax that closely represents
the mathematical operators, and lazy evaluation where applicable. A very interesting part of how lazy
evaluation is implemented in Eigen, is that it is deployed selectively. In some operations, the library
decides at compile time to internally evaluate some subexpressions into temporary variables instead of
computing the whole operation at once. This shows the power of appropriately deployed expression templates.
It can be a way to implement optimizations that could otherwise only be done at the compiler level, while
staying within the ecosystem of the language, and providing an expressive API to the users.

Since Eigen was first released in 2006, a lot has changed on the C++ front, but being the industry standard
that it is, and given the culture of not updating C++, the library still targets C++98. This means, that
while the achievements are impressive and the library definitely holds up to todays standards, C++, and
especially compile-time programming in C++, has changed a lot since. Given this, Eigen is a great example of
what can be achieved using expression templates, but its internals may not the best place to look for
inspiration on how to build an EDSL\footnote{Embedded Domain Specific Language} with expression templates in C++.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{C++20 Ranges}

C++20\autocite{C++Std} merged the long anticipated ranges proposal\autocite{P0896R4}, which was
significant in a number of ways. First of all, it added a lot of fairly simple utility functions and quality
of life improvements to working with containers and algorithms, most notibly range-based versions of all
standard algorithms. This means that functions like \cpp{std::sort} can now be called with a \emph{range} as its first and only
argument, instead of only being available to be called with separate begin and end iterators. The library
defines the concept \cpp{std::range}, which models a type that has \cpp{begin()} and \cpp{end()} functions that return iterators\footnote{Technically, the end function
returns a sentinel, which may be of a different type, but for the sake of this report i will refer to them
both as iterators.}. This abstraction means that a \cpp{std::range} is simply an object that can be iterated over, like any standard container. These objects have always existed, but mostly the functions that use them have had to be passed begin and end iterators directly. This general shift from an iterator-based API to a range-based one, may at first glance appear trivial, but not only does it change \cpp{std::sort(vec.begin(), vec.end())}
to \cpp{std::ranges::sort(vec)}, it also enables some interesting and very convenient syntax for more complex
operations.

The second notable thing about the C++ ranges library, is that it was the first major part of the standard
library to be designed with \emph{concepts}, another C++20 feature\autocite{N4674}, in mind.
Concepts is the umbrella term often used to describe the whole system of static type constraints which was
introduced in C++20\autocite{P0724R0}, while concepts themselves is just a way to name these constraints.
With Concepts and constraints came dedicated language features for selecting function overloads based on
statically evaluated requirements on generic type parameters, something which had previously been done with
library hacks  and use of very esoteric aspects of the C++ template system called
SFINAE\footnote{Substition Failure Is Not An Error. The details of this are largely irrelevant to this report}. There is a lot more to it than that, but for the sake of this section, this
simplified view is enough. With a dedicated language feature came code \emph{and} error messages
that are both a lot easier to reason about. Using SFINAE would often result in hundreds, if not thousands of
lines of error messages, where the source of the initial error could be extremely difficult to trace. This
has even resulted in programmers having to write parsers for the error messages produced by C++
compilers\autocite{Raz2019}. All of this means, that while most of the code in the ranges library could
be (and has been\autocite{range-v3}) implemented before, with C++20 it, and code like it, has become a lot
more feasible to write and maintain.

Thirdly, and most relevant to this report, The C++ Ranges library includes a new way of applying algorithms
to ranges, and especially a new way to compose these algorithms. This is the system of \emph{views}
and their accompanying \emph{range adaptors}. While the basic standard library algorithms and their
range-based variants are applied eagerly, \emph{views} apply algorithms lazily. As an example, lets
take \cpp{std::views::transform(ints, to_string)}, which, given a range of \cpp{int}s and a function from \cpp{int} to  \cpp{std::string}, returns a
\cpp{std::views::transform_view<T, F>}, where \cpp{T} will be the concrete type of the \cpp{ints} range, and \cpp{F} will be the type of the
function \cpp{to_string}. This view is itself a range, that has captured the begin and end iterators of the range, and the function \cpp{to_string}. When iterating over the resulting view, upon each dereference of
an iterator, the underlying iterator into the \cpp{ints} range will be dereferenced, and passed through \cpp{to_string}. This means, while
\cpp{ints} is a range of integers, \cpp{std::views::transform(ints, to_string)} becomes a lazilly computed range of strings,
which could in turn be passed to other views, which would also be lazilly evaluated. As an added bonus, the
ranges library provides an overloaded \cpp{|} (pipe) operator to allow this composition, and with that, code like \autoref{rangesviewsex} can be written. It is worth
noting, that this code, specifically line 4 of \autoref{rangesviewsex} comes very close to some of the syntax
of faust, in that a high level, simple syntax, is used to describe a pipeline that is evaluated vertically
instead of horizontally.

\begin{listing}
  \caption{Example of composition of views. Prints "0 2 4 6". Implementations of supporting functions omitted.}
  \label{rangesviewsex}
  \begin{cppcodenl}
  std::string to_string(int);
  bool is_even(int);

  std::vector<int> ints = {0, 1, 2, 3, 4, 5, 6};
  for (std::string s : ints | std::views::filter(even) | std::views::transform(to_string)) {
      std::cout << s << ' ';
  }
  \end{cppcodenl}
\end{listing}

\section{Conclusion}

In this chapter, I described two existing solutions for DSP in audio applications. Faust provides a DSL for
composing DSP algorithms, and while the syntax is highly expressive, a separately compiled DSL brings with it
issues of integration, versatility and performance. KFR includes highly performant and versatile
implementations of the algorithms, but ends up lacking in expressive syntax for composition, making the
process of building complex applications from basic algorithms cumbersome. There are many other relevant DSP
frameworks and libraries\footnote{\todo{List other relevant DSP frameworks}} that I will not go into here, but they tend to share the
shortcomings of at least one of these systems.

I also covered Eigen and C++ Ranges, which aim to solve some of these issues of expressivity in other
domains, i.e. linear algebra and composition of algorithms on containers respectively. In the rest of this
report I will try to apply the technologies of these two solutions on the domain of DSP in audio
applications, with the goal of proposing a solution to the issues posed by Faust and KFR respectively.
